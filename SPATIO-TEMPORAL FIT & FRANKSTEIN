# In the following script you will find the only-intercept,persistent,opportunistic and progressive configurations to be tested for each sub-region and then how to built the Frankestein model. 
# As methodological workflow, you should first find the best fitting configuration of each subregion and then build the Frankestein SMD.
#The step of indipendet variable selection should be done after finding the best spatio-temporal configuration and the Frankestein SMD built. This step is not shown here   
#In the following example, we consider the region A to have a progressive proprieties and region B as persistent
#For more examples on the three configuration and indipendnet variable selection please refer to https://github.com/FranIzquierdo/R-INLA-Code-Hake-HBSTM


library(INLA)
inla.setOption(scale.model.default = TRUE)
inla.setOption(num.threads = 4) #set number of cores to use

# Create empty 3D array: 4 rows (strategies), 100 cols (simulations), 3 layers (configs)
  data_all <- sim.list[[i]]
  # Create three subset
  data_A <- data_all[data_all$region == "A", ]
  data_B <- data_all[data_all$region == "B", ]
  data_configs <- list(A = data_A, B = data_B)

  
  for (j in 1:length(data_configs)) {
    config_name <- names(data_configs)[j]
    data <- data_configs[[j]]
    location <- as.matrix(data[,c("x","y")])
    boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) 
    MaxEdge <- diff(range(data$x))/15 
    bound.outer <- diff(range(data$y))/5 
    
    mesh<-inla.mesh.2d(loc= location,
                       boundary = boundary,
                       max.edge = c(1,3.5)* MaxEdge, 
                       cutoff =  MaxEdge / 10,
                       offset =c(MaxEdge, bound.outer))
  
    #SPDE make
    spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
    temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y))
    mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde)    
    fit.stack<-inla.stack(data=list(y=data$abundance),
                          A=list(temp,1),
                          effects=list(mesh.index,
                                       list(b0=1,
                                            year=data$time)),
                          tag='fit')
    
    
    f <- y ~ -1 + b0 #only intercept
    mod.T<-inla(f,
                family='gamma',
                data=inla.stack.data(fit.stack),
                control.inla = list(strategy = "gaussian"),
                control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
                control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                verbose=T , num.threads = 4)
   mod.T$waic$waic
  
    #PERSISTENT CONFIGURATION
    f <- y ~ -1 + b0+f(i.bin, model=spde)+f(year,model="iid")
    mod.T<-inla(f,
                family='gamma',
                data=inla.stack.data(fit.stack),
                control.inla = list(strategy = "gaussian"),
                control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
                control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                verbose=T , num.threads = 4)
   mod.T$waic$waic
    rm(mod.T)
    #OPPORTUNISTIC CONFIGURATION
       temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                             repl=data$time,
                             n.repl=length(unique(data$time)))
    mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,n.repl=length(unique(data$time)))
    fit.stack<-inla.stack(data=list(y=data$abundance),
                          A=list(temp,1),
                          effects=list(mesh.index,
                                       list(b0=1,
                                            year=data$time)),
                          tag='fit')
    f <- y ~ -1 + b0+f(i.bin, model=spde,replicate=i.bin.group)
    mod.T<-inla(f,
                family='gamma',
                data=inla.stack.data(fit.stack),
                control.inla = list(strategy = "gaussian"),
                control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
                control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                verbose=T , num.threads = 4)
    mod.T$waic$waic
   #PROGRESSIVE CONFIGURATION 
    temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                             group = data$time,
                             n.group = length(unique(data$time)))
    mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                      n.group =length(unique(data$time))) 
    fit.stack<-inla.stack(data=list(y=data$abundance),
                          A=list(temp,1),
                          effects=list(mesh.index,
                                       list(b0=1,
                                            year=data$time)),
                          tag='fit')
    f <- y ~ -1 + b0+f(i.bin, model=spde,replicate=i.bin.group,
                       control.group = list(model="ar1"))
    mod.T<-inla(f,
                family='gamma',
                data=inla.stack.data(fit.stack),
                control.inla = list(strategy = "gaussian"),
                control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
                control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                verbose=T , num.threads = 4)
    
mod.T$waic$waic

#FRANKESTEIN SDM
    data <- sim.list[[i]]
    data_A <- data[data$region == "A", ]
    data_B <- data[data$region == "B", ]
    
    location <- as.matrix(data[,c("x","y")])
    boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) 
    MaxEdge <- diff(range(data$x))/15 
    bound.outer <- diff(range(data$y))/5 
    #SAME MESH BOTH SUBREGION
    mesh<-inla.mesh.2d(loc= location,
                       boundary = boundary,
                       max.edge = c(1,3.5)* MaxEdge, 
                       cutoff =  MaxEdge / 10,
                       offset =c(MaxEdge, bound.outer))
    #SPDE make
    spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
    
    #matrix of data_A as progressive
    temp_A <- inla.spde.make.A(mesh, loc=cbind(data_A$x, data_A$y),
                               group = data_A$time,
                               n.group = length(unique(data_A$time)))
    #index of data_A as progressive
    mesh.index_A<- inla.spde.make.index("i.con_A", n.spde=spde$n.spde,
                                        n.group =length(unique(data_A$time)))
    #stack data_A
    fit.stack_A<-inla.stack(data=list(y=data_A$abundance),
                            A=list(temp_A,1),
                            effects=list(mesh.index_A,
                                         list(b0_A=1,
                                              year=data_A$time)),
                            tag='fit_A')
    
    temp_B <- inla.spde.make.A(mesh, loc=cbind(data_B$x, data_B$y))
    mesh.index_B<- inla.spde.make.index("i.con_B", n.spde=spde$n.spde)
    
  
    fit.stack_B<-inla.stack(data=list(y=data_B$abundance),
                            A=list(temp_B,1),
                            effects=list(mesh.index_B,
                                         list(b0_B=1,
                                              year=data_B$time)),
                            tag='fit_B')
    fit.stack<- inla.stack(fit.stack_A,fit.stack_B)
    
    prog<-y~-1+b0_A+b0_B+
      f(i.con_A,model=spde,group = i.con_A.group,control.group = list(model="ar1"))+
      f(i.con_B,model=spde)+f(year, model="iid")
    
    mod.frank<-inla(prog,     
                    family='gamma',
                    #control.fixed=list(expand.factor.strategy="inla"),
                    data=inla.stack.data(fit.stack), 
                    control.compute=list(waic=T,dic=F, cpo=F),
                    control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                    verbose=TRUE,control.inla = list(strategy = "gaussian"), num.threads = 4)
    
  mod.frank$waic$waic
