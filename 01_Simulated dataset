# This script simulates spatio-temporal abundance data for two distinct ecological regions (A and B), 
# to test species distribution model (SDM) configurations under controlled conditions. 
# The simulation is designed to reflect heterogeneous spatio-temporal dynamics: Region A follows 
# a progressive dynamic (i.e., spatio-temporal AR(1) process with a decreasing spatial correlation over time), 
# while Region B follows a persistent dynamic (i.e., fixed spatial field with a linear temporal trend).
#
# A 10 × 10 regular grid is generated for each region, and spatial autocorrelation is introduced using an 
# exponential covariance function. Temporal dynamics are added to Region A via an AR(1) process with 
# a linear trend, whereas Region B maintains a static spatial structure with additive temporal progression.
#
# Abundance observations are simulated using a Negative Binomial distribution with log-normal observational error 
# to mimic realistic ecological count data, avoiding zeros by adding 1 to each value. The final output is a tidy 
# data frame combining both regions, including spatial coordinates, time, and abundance values.
#
# This synthetic dataset is intended for evaluating the fit and predictive capacity of different SDM configurations 
# (only-intercept, persistent, opportunistic, progressive) and for building the Frankenstein SDM, which integrates 
# region-specific spatio-temporal structures. This script does not include independent variable selection, which should 
# be performed after identifying the best-fitting configuration for each subregion.

library(MASS)# mvrnorm()
  {
  set.seed(123)
  ##Parameter -------------------- ##
  n.rep         <- 30          # number of dataset to simulate
  n.time        <- 4           # time unit
  rho           <- 0.8         # rho parameter of AR(1) – region A
  gamma.shape   <- 5          # (≈ NB ‘size’)
  gamma.scale   <- 10          # mean starting value
  mu0           <- gamma.shape*gamma.scale  # ≈ 200 
  trend.B       <- 0.1        # linear trend in region B
  trend.A       <- 0.4        # linear trend in region A
  sigma2        <- 0.6           # variance of spatial field
  phi.B           <- 0.6        # range parameter for region B
  sd.obs        <- 0.1        # observation error parameter (log-normal)
  phi.vec   <- seq(0.8, 0.1, length.out = n.time) #vector of range parmeters for region A
  ## --------------------------------------------------------- ##
  
  
  ## regular grid generation 10 × 10
    grid.coord <- function(xmin, xmax, ymin = 0, ymax = 1, n = 10){
    expand.grid(
      x = seq(xmin + (xmax-xmin)/(2*n), xmax - (xmax-xmin)/(2*n), length.out = n),
      y = seq(ymin + (ymax-ymin)/(2*n), ymax - (ymax-ymin)/(2*n), length.out = n)
    )
  }
  
  A.xy <- grid.coord(0   , 0.5)   # regione A (100 punti)
  B.xy <- grid.coord(0.5 , 1  )   # regione B (100 punti)
  n.A  <- nrow(A.xy); n.B <- nrow(B.xy)
  
  ## spatial covariance matrix (exponential kernel)
  expCov <- function(coords, phi) {
    d <- as.matrix(dist(coords))
    sigma2 * exp(-d / phi)
  }  
  ##Simulation scenario
  one.sim <- function(){
    field.A <- matrix(NA, n.time, n.A)
    for(t in 1:n.time){
      phi.t     <- phi.vec[t]
      Sigma.A.t <- expCov(A.xy, phi = phi.t)
      #Sigma.A.t <- expCov(A.xy) * exp(-as.matrix(dist(A.xy)) / phi.t)
      chol.A.t  <- chol(Sigma.A.t)
      eps.A.t   <- rnorm(n.A) %*% chol.A.t
      if(t == 1){
        field.A[t, ] <- eps.A.t
      } else {
        field.A[t, ] <- rho * field.A[t-1, ] + sqrt(1 - rho^2) * eps.A.t + trend.A
      }
    }
    ##Region B: linear trend + fixed spatial field
    Sigma.B <- expCov(B.xy, phi.B);  chol.B <- chol(Sigma.B)
    S.B     <- as.numeric(rnorm(n.B) %*% chol.B)      # parte spaziale
    field.B <- outer(0:(n.time-1), S.B,
                     function(tt, sb) sb + trend.B*tt)
    
    ##Gamma distribution Observation from NB + observation error
    obs.A <- obs.B <- vector("list", n.time)
    for(t in 1:n.time){
      mu.A <- mu0 * exp(field.A[t, ] + rnorm(n.A, 0, sd.obs))
      mu.B <- mu0 * exp(field.B[t, ] + rnorm(n.B, 0, sd.obs))
      
      ## Conteggi: Negative Binomial + 1 (per evitare zeri)
      ## In R: 'size' = gamma.shape, 'mu' = media desiderata
      obs.A[[t]] <- rnbinom(n.A, size = gamma.shape, mu = mu.A) + 1L
      obs.B[[t]] <- rnbinom(n.B, size = gamma.shape, mu = mu.B) + 1L
    }
    
    ## -------- Assembly of data frame “tidy” -------- ##
    datA <- data.frame(
      region    = "A",
      time      = rep(1:n.time, each = n.A),
      A.xy[rep(1:n.A, n.time), ],
      abundance = unlist(obs.A)
    )
    datB <- data.frame(
      region    = "B",
      time      = rep(1:n.time, each = n.B),
      B.xy[rep(1:n.B, n.time), ],
      abundance = unlist(obs.B)
    )
    
    ## Check: integer number, no zero
    stopifnot(all(datA$abundance > 0),
              all(datB$abundance > 0),
              all(datA$abundance %% 1 == 0),
              all(datB$abundance %% 1 == 0))
    
    rbind(datA, datB)
  }
   sim.list <- lapply(1:n.rep, function(i) one.sim())
