#This script is to project the three single configurations and the Frankestein SDM using the first simulated dataset of the list object that can be found in the repository /data/
#Finally the contour plot is created for the observed data and projected output of the three configuration and the Frankestein model. 
#This is to create figure 3 in the manuscript 
library(INLA)

##SELECT THE FIRST SIMULATED DATASET------------------------------------------
data <- sim.list.final[[1]]
n.fit<- nrow(data)

###PROJECT PERSISTENT CONFIGURATION-----------------------------------
{
  location <- as.matrix(data[,c("x","y")])
  boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) #mettere prediction dataset per predizione 
  MaxEdge <- diff(range(data$x))/15 #mettere prediction dataset per predizione 
  bound.outer <- diff(range(data$y))/5 #mettere prediction dataset per predizione 
  
  mesh<-inla.mesh.2d(loc= location,
                     boundary = boundary,
                     max.edge = c(1,3.5)* MaxEdge, #ridurre 2 fino 0.5 per risoluzione maggiore
                     cutoff =  MaxEdge / 10,
                     offset =c(MaxEdge, bound.outer))
  #plot(mesh)
  #points(location)
  #SPDE make
  spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
  #obs
  temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y))
  mesh.index<- inla.spde.make.index("i.con", n.spde=spde$n.spde)

  
  fit.stack<-inla.stack(data=list(y=data$abundance),
                        A=list(temp,1),
                        effects=list(mesh.index,
                                     list(b0=1,
                                          year=data$time)),
                        tag='fit')
  f <- y ~ -1 + b0+f(i.con, model=spde)+f(year,model="iid")
  mod.T<-inla(f,
              family='gamma',
              data=inla.stack.data(fit.stack),
              control.inla = list(strategy = "gaussian"),
              control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
              control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE, link=1),
              verbose=T , num.threads = 4)
  
  data$pred.pers<- mod.T$summary.fitted.values[c(1:n.fit),1]
  rm(mod.T)
  
  ###PROJECT OPPORTUNISTIC CONFIGURATION---------------------------------- 
  #with year separated
  temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                           repl=data$time,
                           n.repl=length(unique(data$time)))
  mesh.index<- inla.spde.make.index("i.con", n.spde=spde$n.spde,n.repl=length(unique(data$time))) 
  
  fit.stack<-inla.stack(data=list(y=data$abundance),
                        A=list(temp,1),
                        effects=list(mesh.index,
                                     list(b0=1,
                                          year=data$time)),
                        tag='fit')
  f <- y ~ -1 + b0+f(i.con, model=spde,replicate=i.con.group)
  mod.T<-inla(f,
              family='gamma',
              data=inla.stack.data(fit.stack),
              control.inla = list(strategy = "gaussian"),
              control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
              control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
              verbose=T , num.threads = 4)
  
  data$pred.opp<- mod.T$summary.fitted.values[c(1:n.fit),1]
  rm(mod.T)
  ###PROJECT PROGRESSIVE CONFIGURATION---------------------------- 
  temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                           group = data$time,
                           n.group = length(unique(data$time)))
  mesh.index<- inla.spde.make.index("i.con", n.spde=spde$n.spde,
                                    n.group =length(unique(data$time))) #test spde with or without prior
  
  fit.stack<-inla.stack(data=list(y=data$abundance),
                        A=list(temp,1),
                        effects=list(mesh.index,
                                     list(b0=1,
                                          year=data$time)),
                        tag='fit')
  
  f <- y ~ -1 + b0+f(i.con, model=spde,replicate=i.con.group,
                     control.group = list(model="ar1"))
  mod.T<-inla(f,
              family='gamma',
              data=inla.stack.data(fit.stack),
              control.inla = list(strategy = "gaussian"),
              control.compute=list(dic=F, cpo=F, waic=T, return.marginals=TRUE),
              control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
              verbose=T , num.threads = 4)
  
  data$pred.prog<- mod.T$summary.fitted.values[c(1:n.fit),1]
  rm(mod.T)
  
  ###PROECT FRANKENSTEIN MODEL-----------------------------------
  #split data
  data_A<- data[(data$region=="A"),]
  data_B<- data[(data$region=="B"),]
  n.fit.A<- nrow(data_A)
  n.fit.B<- nrow(data_B)
  #slipt pred grid

  location <- as.matrix(data[,c("x","y")])
  boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) #mettere prediction dataset per predizione 
  MaxEdge <- diff(range(data$x))/15 #mettere prediction dataset per predizione 
  bound.outer <- diff(range(data$y))/5 #mettere prediction dataset per predizione 
  
  mesh<-inla.mesh.2d(loc= location,
                     boundary = boundary,
                     max.edge = c(1,3.5)* MaxEdge, #ridurre 2 fino 0.5 per risoluzione maggiore
                     cutoff =  MaxEdge / 10,
                     offset =c(MaxEdge, bound.outer))
  #plot(mesh)
  #points(location)
  #SPDE make
  spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
  
  #matrix of data_A as progressive
  temp.A <- inla.spde.make.A(mesh, loc=cbind(data_A$x, data_A$y),
                             group = data_A$time,
                             n.group = length(unique(data_A$time)))
  #index of data_A as progressive
  mesh.index.A<- inla.spde.make.index("i.con.A", n.spde=spde$n.spde,
                                      n.group =length(unique(data_A$time))) #test spde with or without prior
  #stack data_A
  fit.stack_A<-inla.stack(data=list(y=data_A$abundance),
                          A=list(temp.A,1),
                          effects=list(mesh.index.A,
                                       list(b0_A=1,
                                            year=data_A$time)),
                          tag='fit_A')
  

  temp.B <- inla.spde.make.A(mesh, loc=cbind(data_B$x, data_B$y))
  mesh.index.B<- inla.spde.make.index("i.con.B", n.spde=spde$n.spde) #test spde with or without prior
  
  fit.stack_B<-inla.stack(data=list(y=data_B$abundance),
                          A=list(temp.B,1),
                          effects=list(mesh.index.B,
                                       list(b0_B=1,
                                            year=data_B$time)),
                          tag='fit_B')
 
  combo.stack<- inla.stack(fit.stack_A,fit.stack_B)
  
  f.frank<-y~-1+b0_A+b0_B+
    f(i.con.A,model=spde,group = i.con.A.group,control.group = list(model="ar1"))+
    f(i.con.B,model=spde)+f(year, model="iid")
  
  mod.frank<-inla(f.frank,     
                  family='gamma',
                  data=inla.stack.data(combo.stack), 
                  control.compute=list(waic=T,dic=F, cpo=F, return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(combo.stack), compute=TRUE, link=1),
                  verbose=TRUE,control.inla = list(strategy = "gaussian"), num.threads = 4)
  
  pred.A.frank<- mod.frank$summary.fitted.values[(1:n.fit.A),1]
  pred.B.frank<- mod.frank$summary.fitted.values[(n.fit.A+1):(n.fit.A+n.fit.B),1]
  data$pred.frank<- c(pred.A.frank,pred.B.frank)
}
library(tidyverse)
library(ggplot2)
colnames(data)[5:9]<- c("SIM.DATA","PERS","OPPO","PROG","FRANK")
data_plot<- data %>% pivot_longer(cols = c(5:9), names_to = "conf")
data_plot$conf<-  factor(data_plot$conf, levels = c("SIM.DATA","PERS","OPPO","PROG","FRANK")) 
p<-ggplot(data_plot, aes(x = x, y = y, z = value)) +
  geom_contour_filled(bins = 15) +
  geom_vline(xintercept = 0.5, linetype = "dashed", color = "red") + 
  facet_grid(conf~ time) +
  coord_fixed() +
  scale_x_continuous(breaks = c(0.5))+
  theme_minimal() +
  theme(legend.position = "none") +  # <-- Removes the legend
  labs(x = "X Coordinate", y = "Y Coordinate")
p
