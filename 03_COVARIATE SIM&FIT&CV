## --- Covariates for each of the 30 datasets ---
## Idea:
##  - cov1: linear-noisy function of abundance **only in region A**; random for others
##  - cov2: linear-noisy function of abundance **only in region B**; random for others
##  - then z-score each covariate within the dataset
##  - store back into sim.list

set.seed(123)  # one global seed for reproducibility across the whole loop
sim.list.cov<- list()
for (i in seq_along(sim.list)) {
  data <- sim.list[[i]]
  stopifnot(all(c("region", "abundance") %in% names(data)))
  
  idxA <- data$region == "A"
  idxB <- data$region == "B"
  
  # --- cov1: driven by abundance in region A; random elsewhere
  aA  <- runif(1, min = 5,  max = 200)
  # keep slope away from 0 to avoid blow-ups
  bA  <- sample(c(runif(1, -10, -2), runif(1, 2, 10)), size = 1)
  sdA <- runif(1, min = 0,  max = 1.5)
  errA <- rnorm(sum(idxA), mean = 0, sd = sdA)
  
  cov1 <- numeric(nrow(data))
  cov1[idxA]  <- (data$abundance[idxA] - aA - errA) / bA
  cov1[!idxA] <- rgamma(sum(!idxA), shape = sample(c(5, 80, 10, 60), sum(!idxA), replace = TRUE),
                        rate  = 10)
  
  # --- cov2: driven by abundance in region B; random elsewhere
  aB  <- runif(1, min = 5,  max = 200)
  bB  <- sample(c(runif(1, -10, -2), runif(1, 2, 10)), size = 1)
  sdB <- runif(1, min = 0.1,  max = 1.5)
  errB <- rnorm(sum(idxB), mean = 0, sd = sdB)
  
  cov2 <- numeric(nrow(data))
  cov2[idxB]  <- (data$abundance[idxB] - aB - errB) / bB
  cov2[!idxB] <- rgamma(sum(!idxB), shape = sample(c(5, 80, 10, 60), sum(!idxB), replace = TRUE),
                        rate  = 1)
  
  # standardize within dataset (as.numeric() to drop "matrix" class from scale())
  data$cov1 <- as.numeric(scale(cov1))
  data$cov2 <- as.numeric(scale(cov2))
  
  # store back
  sim.list.cov[[i]] <- data
}


{
  library(INLA)
  inla.setOption(scale.model.default = TRUE)
  inla.setOption(num.threads = 24)
  # Create empty 3D array: 4 rows (strategies), 100 cols (simulations), 3 layers (configs)
  sp.tem.arr <- array(NA, dim = c(5, 30),
                      dimnames = list(
                        c('SPDE.IID',
                          'REP',
                          'GR.AR1','GR.IID', 
                          'FRANK'
                          ),
                        paste0('sim_', 1:30)
                        ))
  
  for (i in 1:30) {
    data <- sim.list.cov[[i]]
      location <- as.matrix(data[,c("x","y")])
      boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) #mettere prediction dataset per predizione 
      MaxEdge <- diff(range(data$x))/15 #mettere prediction dataset per predizione 
      bound.outer <- diff(range(data$y))/5 #mettere prediction dataset per predizione 
      
      mesh<-inla.mesh.2d(loc= location,
                         boundary = boundary,
                         max.edge = c(1,3.5)* MaxEdge, #ridurre 2 fino 0.5 per risoluzione maggiore
                         cutoff =  MaxEdge / 10,
                         offset =c(MaxEdge, bound.outer))
    
      #SPDE make
      spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
      temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde) #test spde with or without prior

      fit.stack<-inla.stack(data=list(y=data$abundance),
                            A=list(temp,1),
                            effects=list(mesh.index,
                                         list(b0=1,
                                              year=data$time, 
                                              cov1=data$cov1, 
                                              cov2=data$cov2)),
                            tag='fit')
      
      
      ##PERS--------------------------------
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde)+f(year, model='iid')
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=T, waic=T, return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                  verbose=T , num.threads = 4)
      
       sp.tem.arr[1,i]<- mod.T$waic$waic
       rm(mod.T)
     ##OPP/REPL---------------------------- 
      #with year separated
      temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                               repl=data$time,
                               n.repl=length(unique(data$time)))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                        n.repl=length(unique(data$time))) #test spde with or without prior
      fit.stack<-inla.stack(data=list(y=data$abundance),
                            A=list(temp,1),
                            effects=list(mesh.index,
                                         list(b0=1,
                                              year=data$time, cov1=data$cov1, cov2=data$cov2)),
                            tag='fit')
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,replicate=i.bin.repl)
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=T, waic=T, return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                  verbose=T , num.threads = 20)
      sp.tem.arr[2,i]<- mod.T$waic$waic
      rm(mod.T)
      ##GROUP/AR1--------------------- 
      temp <- inla.spde.make.A(mesh, loc=cbind(data$x, data$y),
                               group = data$time,
                               n.group = length(unique(data$time)))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                        n.group =length(unique(data$time))) #test spde with or without prior
      fit.stack<-inla.stack(data=list(y=data$abundance),
                            A=list(temp,1),
                            effects=list(mesh.index,
                                         list(b0=1,
                                              year=data$time, cov1=data$cov1, cov2=data$cov2)),
                            tag='fit')
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,group =i.bin.group,
                         control.group = list(model="ar1"))
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=T, waic=T, return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                  verbose=T , num.threads = 20)
      
     sp.tem.arr[3,i]<- mod.T$waic$waic #smaller is better
      rm(mod.T)
      ##GROUP/IID----------------------------
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,group =i.bin.group,
          control.group = list(model="iid"))
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=T, waic=T, return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                  verbose=T , num.threads = 20)
      
      sp.tem.arr[4,i]<- mod.T$waic$waic
      rm(mod.T)
      
#FRANK FIT---------------
  data_A <- data[data$region == "A", ]
  data_B <- data[data$region == "B", ]
  
  #Now I fit the frankestein model and compare with best WAIC of the data_all (15216.75)
  location <- as.matrix(data[,c("x","y")])
  boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) #mettere prediction dataset per predizione 
  MaxEdge <- diff(range(data$x))/15 #mettere prediction dataset per predizione 
  bound.outer <- diff(range(data$y))/5 #mettere prediction dataset per predizione 
  
  mesh<-inla.mesh.2d(loc= location,
                     boundary = boundary,
                     max.edge = c(1,3.5)* MaxEdge, #ridurre 2 fino 0.5 per risoluzione maggiore
                     cutoff =  MaxEdge / 10,
                     offset =c(MaxEdge, bound.outer))
 
  #SPDE make
  spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
  
  #matrix of data_A as progressive
  temp_A <- inla.spde.make.A(mesh, loc=cbind(data_A$x, data_A$y),
                             group = data_A$time,
                             n.group = length(unique(data_A$time)))
  #index of data_A as progressive
  mesh.index_A<- inla.spde.make.index("i.con.A", n.spde=spde$n.spde,
                                      n.group =length(unique(data_A$time))) #test spde with or without prior
  #stack data_A
  fit.stack_A<-inla.stack(data=list(y=data_A$abundance),
                          A=list(temp_A,1),
                          effects=list(mesh.index_A,
                                       list(b0_A=1,
                                            year=data_A$time,
                                            cov1=data_A$cov1)),
                          tag='fit_A')
  
  temp_B <- inla.spde.make.A(mesh, loc=cbind(data_B$x, data_B$y))
  mesh.index_B<- inla.spde.make.index("i.con.B", n.spde=spde$n.spde) #test spde with or without prior
  
 
  fit.stack_B<-inla.stack(data=list(y=data_B$abundance),
                          A=list(temp_B,1),
                          effects=list(mesh.index_B,
                                       list(b0_B=1,
                                            year=data_B$time,
                                            cov2=data_B$cov2)),
                          tag='fit_B')
    fit.stack<- inla.stack(fit.stack_A,fit.stack_B)
  
  prog<-y~-1+b0_A+b0_B+cov1+cov2+
    f(i.con.A,model=spde,group = i.con.A.group,control.group = list(model="ar1"))+
    f(i.con.B,model=spde)+f(year, model="iid")
        
  mod.frank<-inla(prog,     
                  family='gamma',
                  data=inla.stack.data(fit.stack), 
                  control.compute=list(waic=T,dic=F, cpo=T,return.marginals=TRUE),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE),
                  control.inla = list(strategy = "gaussian"), 
                  verbose=TRUE, num.threads = 20)
  

  sp.tem.arr[5,i]<-mod.frank$waic$waic
  rm(mod.frank)
}
saveRDS(sp.tem.arr,"WAIC.cov.reg2.rds")

}
library(ggplot2)
library(viridis)
library(tidyverse)
library(rstatix)
df <- as.data.frame.table(WAIC.cov.reg2, responseName = "Value") %>%
  rename(Group = Var1,
         Simulation = Var2
         )

df_mean <- df %>%
  group_by(Simulation) %>%
  mutate(mean_sim = mean(Value, na.rm = TRUE))%>%
  mutate(sd_sim = sd(Value, na.rm = TRUE))%>%
  mutate(delta_sim= (Value-mean_sim)/sd_sim)
  
p<-ggplot(df_mean, aes(x =Group , y = delta_sim)) +
  geom_boxplot() +
  labs(x = "Configuration",
       y = "Scaled WAIC") +
  scale_y_continuous(breaks = c(-1.5,-1,-0.5,0,0.5,1,1.5))+
  theme_minimal()
p

friedman.test(delta_sim ~ Group | Simulation, data = df_mean)
df_mean<- df_mean[,c(1,6)]
wilcox_test<-df_mean %>%
  wilcox_test(delta_sim ~ Group , p.adjust.method = "bonferroni")
write.csv(wilcox_test, "wilcox_test_All.frank.group2.cov.csv")

df_mean<- df_mean[,c(1,6)]
dunn_test<-df_mean%>%
  dunn_test(delta_sim ~ Group , p.adjust.method = "bonferroni")
write.csv(dunn_test, "dunn_test_All.cov.lpml.csv")
#CV---------------
library(caret)
{
  rmse <- array(NA, dim = c(5, 30),
                dimnames = list(
                  c('SPDE.IID',
                    'REP',
                    'GR.AR1','GR.IID', 
                    #'GR.RW2'
                    'FRANK'
                  ),
                  paste0('sim_', 1:30)#,
                  # c('A','B')
                ))
  
  for (i in 1:30) {
    rmse.loop <- array(NA, dim = c(5, 5),
                       dimnames = list(
                         c('SPDE.IID',
                           'REP',
                           'GR.AR1','GR.IID', 
                          'FRANK'
                         ),
                         paste0('loop_', 1:5)#,
                         # c('A','B')
                       ))
    data_all <- sim.list.cov[[i]]
    # Create three configurations
    data<-data_all
    data_A <- data_all[data_all$region == "A", ]
    data_B <- data_all[data_all$region == "B", ]
    location <- as.matrix(data[,c("x","y")])
    boundary <- inla.nonconvex.hull(as.matrix(data[,c("x","y")])) #mettere prediction dataset per predizione 
    MaxEdge <- diff(range(data$x))/15 #mettere prediction dataset per predizione 
    bound.outer <- diff(range(data$y))/5 #mettere prediction dataset per predizione 
    
    mesh<-inla.mesh.2d(loc= location,
                       boundary = boundary,
                       max.edge = c(1,3.5)* MaxEdge, #ridurre 2 fino 0.5 per risoluzione maggiore
                       cutoff =  MaxEdge / 10,
                       offset =c(MaxEdge, bound.outer))
    spde <- inla.spde2.pcmatern(mesh,prior.range=c(0.5, 0.05), prior.sigma=c(0.6, 0.05))
    data$loc_id <- interaction(data$region, data$time,drop = TRUE)
    folds <- createDataPartition(data$loc_id, p = 0.8, list = FALSE,times = 10)
    
    for (k in 1:5) {
      id_fold<- folds[,k]
      train.df  <- data[ id_fold, ]
      val.df    <- data[-id_fold, ]
      train.n<-nrow(train.df)
      val.n<-nrow(val.df)
      #compone elements for model
      temp <- inla.spde.make.A(mesh, loc=cbind(train.df$x, train.df$y))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde)
      
      train.stack<-inla.stack(data=list(y=train.df$abundance),
                              A=list(temp,1),
                              effects=list(mesh.index,
                                           list(b0=1,
                                                year=train.df$time,cov1=train.df$cov1,cov2=train.df$cov2)),
                              tag='train')
      temp.val <- inla.spde.make.A(mesh, loc=cbind(val.df$x, val.df$y))
      val.stack<-inla.stack(data=list(y=NA),
                            A=list(temp.val,1),
                            effects=list(mesh.index,
                                         list(b0=1,
                                              year=val.df$time,cov1=val.df$cov1,cov2=val.df$cov2)),
                            tag='val')
      fit.stack<- inla.stack(train.stack,val.stack)
      ##PERS--------------------------------
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde)+f(year, model='iid')
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=F, waic=F, return.marginals=F),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
                  verbose=T , num.threads = 4)
      
      # CPO per observation (leave-one-out predictive density)
      yhat <- mod.T$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      obs<- val.df$abundance
      
      rmse.loop[1,k] <- sqrt(mean( (obs - yhat)^2, na.rm=TRUE ))
      rm(mod.T)
      
      ##OPP/REPL---------------------------- 
      #with year separated
      temp <- inla.spde.make.A(mesh, loc=cbind(train.df$x, train.df$y),
                               repl=train.df$time,
                               n.repl=length(unique(train.df$time)))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                        n.repl=length(unique(train.df$time))) #test spde with or without prior
      train.stack<-inla.stack(data=list(y=train.df$abundance),
                              A=list(temp,1),
                              effects=list(mesh.index,
                                           list(b0=1,
                                                year=train.df$time,cov1=train.df$cov1,cov2=train.df$cov2)),
                              tag='train')
      
      temp.val <- inla.spde.make.A(mesh, loc=cbind(val.df$x, val.df$y),
                                   repl=val.df$time,
                                   n.repl=length(unique(val.df$time)))
      mesh.index.val<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                            n.repl=length(unique(val.df$time))) #test spde with or without prior
      val.stack<-inla.stack(data=list(y=NA),
                            A=list(temp.val,1),
                            effects=list(mesh.index.val,
                                         list(b0=1,
                                              year=val.df$time,cov1=val.df$cov1,cov2=val.df$cov2)),
                            tag='val')
      fit.stack<- inla.stack(train.stack,val.stack)
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,replicate=i.bin.repl)
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=F, waic=F, return.marginals=F),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
                  verbose=T , num.threads = 4)
      yhat <- mod.T$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      obs<- val.df$abundance
      
      rmse.loop[2,k] <- sqrt(mean( (obs - yhat)^2, na.rm=TRUE ))
      rm(mod.T)
      ##GR.AR1---------------------
      temp <- inla.spde.make.A(mesh, loc=cbind(train.df$x, train.df$y),
                               group = train.df$time,
                               n.group = length(unique(train.df$time)))
      mesh.index<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                        n.group =length(unique(train.df$time))) #test spde with or without prior
      train.stack<-inla.stack(data=list(y=train.df$abundance),
                              A=list(temp,1),
                              effects=list(mesh.index,
                                           list(b0=1,
                                                year=train.df$time,cov1=train.df$cov1,cov2=train.df$cov2)),
                              tag='train')
      
      temp.val <- inla.spde.make.A(mesh, loc=cbind(val.df$x, val.df$y),
                                   group = val.df$time,
                                   n.group = length(unique(val.df$time)))
      mesh.index.val<- inla.spde.make.index("i.bin", n.spde=spde$n.spde,
                                            n.group =length(unique(val.df$time))) #test spde with or without prior
      val.stack<-inla.stack(data=list(y=NA),
                            A=list(temp.val,1),
                            effects=list(mesh.index.val,
                                         list(b0=1,
                                              year=val.df$time,cov1=val.df$cov1,cov2=val.df$cov2)),
                            tag='val')
      fit.stack<-inla.stack(train.stack,val.stack)
      
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,group =i.bin.group,
          control.group = list(model="ar1"))
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=F, waic=F, return.marginals=F),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
                  verbose=T , num.threads = 4)
      yhat <- mod.T$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      obs<- val.df$abundance
      rmse.loop[3,k] <- sqrt(mean( (obs - yhat)^2, na.rm=TRUE ))#smaller is better
      rm(mod.T)
      ##GR.IID
      f <- y ~ -1 + b0+cov1+cov2+
        f(i.bin, model=spde,group =i.bin.group,
          control.group = list(model="iid"))
      mod.T<-inla(f,
                  family='gamma',
                  data=inla.stack.data(fit.stack),
                  control.inla = list(strategy = "gaussian"),
                  control.compute=list(dic=F, cpo=F, waic=F, return.marginals=F),
                  control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
                  verbose=T , num.threads = 4)
      yhat <- mod.T$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      obs<- val.df$abundance
      rmse.loop[4,k] <- sqrt(mean( (obs - yhat)^2, na.rm=TRUE ))#smaller is better
      rm(mod.T)
      ##FRANK----------------
      
      train.data_A <- train.df[train.df$region == "A", ]
      train.data_B <- train.df[train.df$region == "B", ]
      val.data_A <- val.df[val.df$region == "A", ]
      val.data_B <- val.df[val.df$region == "B", ]
      n.a.t<- nrow(train.data_A); n.b.t<- nrow(train.data_B)
      n.a.v<-nrow(val.data_A); n.b.v<- nrow(val.data_B)
      
      temp_A <- inla.spde.make.A(mesh, loc=cbind(train.data_A$x, train.data_A$y),
                                 group = train.data_A$time,
                                 n.group = length(unique(train.data_A$time)))
      #index of data_A as progressive
      mesh.index_A<- inla.spde.make.index("i.con.A", n.spde=spde$n.spde,
                                          n.group =length(unique(train.data_A$time))) #test spde with or without prior
      #stack data_A
      train.stack_A<-inla.stack(data=list(y=train.data_A$abundance),
                                A=list(temp_A,1),
                                effects=list(mesh.index_A,
                                             list(b0_A=1,
                                                  year=train.data_A$time,cov1=train.data_A$cov1)),
                                tag='fit_A')
      
      temp_B <- inla.spde.make.A(mesh, loc=cbind(train.data_B$x, train.data_B$y))
      mesh.index_B<- inla.spde.make.index("i.con.B", n.spde=spde$n.spde) #test spde with or without prior
      
      
      train.stack_B<-inla.stack(data=list(y=train.data_B$abundance),
                                A=list(temp_B,1),
                                effects=list(mesh.index_B,
                                             list(b0_B=1,
                                                  year=train.data_B$time,cov2=train.data_B$cov2)),
                                tag='fit_B')
      
      temp_A_val <- inla.spde.make.A(mesh, loc=cbind(val.data_A$x, val.data_A$y),
                                     group = val.data_A$time,
                                     n.group = length(unique(val.data_A$time)))
      
      #stack data_A
      val.stack_A<-inla.stack(data=list(y=NA),
                              A=list(temp_A_val,1),
                              effects=list(mesh.index_A,
                                           list(b0_A=1,
                                                year=val.data_A$time,cov1=val.data_A$cov1)),
                              tag='val_A')
      
      temp_B_val <- inla.spde.make.A(mesh, loc=cbind(val.data_B$x, val.data_B$y))
      
      val.stack_B<-inla.stack(data=list(y=NA),
                              A=list(temp_B_val,1),
                              effects=list(mesh.index_B,
                                           list(b0_B=1,
                                                year=val.data_B$time,cov2=val.data_B$cov2)),
                              tag='val_B')
      
      
      fit.stack<- inla.stack(train.stack_A,train.stack_B,val.stack_A,val.stack_B)
      prog<-y~-1+b0_A+b0_B+cov1+cov2+
        f(i.con.A,model=spde,group = i.con.A.group,control.group = list(model="ar1"))+
        f(i.con.B,model=spde)+f(year, model="iid")
      
      mod.frank<-inla(prog,     
                      family='gamma',
                      data=inla.stack.data(fit.stack),
                      control.inla = list(strategy = "gaussian"),
                      control.compute=list(dic=F, cpo=F, waic=F, return.marginals=F),
                      control.predictor=list(A=inla.stack.A(fit.stack), compute=TRUE,link=1),
                      verbose=T , num.threads = 4)
      yhat.a <- mod.frank$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      yhat.b <- mod.frank$summary.fitted.values[(train.n+1):(train.n+val.n),1]  # mean of predictive (response scale)
      yhat<- cbind(yhat.a,yhat.b)
      obs<- val.df$abundance
      rmse.loop[5,k] <- sqrt(mean( (obs - yhat)^2, na.rm=TRUE ))#smaller is better
      
    }
    rmse[,i]<- rowMeans(rmse.loop, na.rm = TRUE) #only frank
    
  }
  saveRDS(rmse,"rmse_CV_all_cov.rds")
}
df <- as.data.frame.table(WAIC.cov.reg2, responseName = "Value") %>%
  rename(Group = Var1,
         Simulation = Var2
         )

df_mean <- df %>%
  group_by(Simulation) %>%
  mutate(mean_sim = mean(Value, na.rm = TRUE))%>%
  mutate(sd_sim = sd(Value, na.rm = TRUE))%>%
  mutate(delta_sim= (Value-mean_sim)/sd_sim)

p<-ggplot(df_mean, aes(x =Group , y = delta_sim)) +
  geom_boxplot() +
  labs(x = "Configuration",
       y = "Scaled WAIC") +
  #facet_wrap(~Category)+
  scale_y_continuous(breaks = c(-1.5,-1,-0.5,0,0.5,1,1.5))+
  theme_minimal()
p

friedman.test(delta_sim ~ Group | Simulation, data = df_mean)
df_mean<- df_mean[,c(1,6)]
wilcox_test<-df_mean %>%
  wilcox_test(delta_sim ~ Group , p.adjust.method = "bonferroni")
write.csv(wilcox_test, "wilcox_test_All.frank.group4.rmse.cov.csv")

